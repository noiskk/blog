---
layout: post
title: "CH2. Computer Abstractions and Technology"
date: 2024-09-27 12:00:00 +0900
categories: Computer_Architecture
---
## Instruction Set : Language of the Computer

**Instruction(명령어)**

컴퓨터 프로세서가 수행할 수 있는 기본적인 작업을 정의하는 기계어 코드.  
CPU 는 명령어에 따라 연산을 수행한다.  
  

## **Number Representation**

`10010010 00101100 11110011 00001000`

MSB : 가장 높은 자리의 bit 로 가장 왼쪽에 위치한다.  
LSB : 가장 낮은 자리의 bit 로 가장 오른쪽에 위치한다.  
<br>  

> **Unsigned & Signed**

-   **Unsigned**는  **음수 없이 양수만**  표현할 때 사용된다.
-   32bits unsigned 정수는  **0부터 4,294,967,295**까지 표현할 수 있다.
-   `10010010 00101100 11110011 00001000`  =  **2452419336**  
      
    
-   **Signed**는  **양수와 음수를 모두**  표현한다.
-   MSB는  **부호 비트**로 사용된다.
    -   **0**이면 양수,  **1**이면 음수.
-   32bits signed 정수는  **-2,147,483,648부터 2,147,483,647**까지 표현할 수 있다.
-   `10010010 00101100 11110011 00001000`  =  **– 1842547960**  
<br> <br>       

> **2’s complement 2의 보수**

-   **음수를 표현하는 방법**  , 해당 양수의 bit를  **반전**한 후  **1을 더하여**  구한다.
-   `00010010 00101100`  = 4652
    1.  bit 반전 –>  `11101101 11010011`
    2.  1 더하기 –>  `11101101 11010100`  = –4652  
<br><br>       

----------
<br>     

## **Von-Neumann Model 폰 노이만 구조**

<br>     
<img src="assets/img/Von Neumann.png" alt="Von Neumann" width="500"/>
<br><br>          

**폰 노이만(John von Neumann) 컴퓨터 구조**는 현대 컴퓨터 시스템의 기본적인 설계 원칙 중 하나로, 이 구조는 프로그램이 실행되는 방식을 정의하며, 대부분의 컴퓨터에서 사용된다.

1.  **단일 메모리 구조**
    -   **명령어(프로그램 코드)**와  **데이터**가 같은 메모리 공간에 저장된다.
    -   이것은 이전의 하버드 구조와는 다르게 프로그램과 데이터를 분리하지 않고, 동일한 메모리 공간을 공유하게 한다.
2.  **프로그램 내장 방식**
    -   폰 노이만 구조에서는  **프로그램이 메모리에 저장되어**  실행된다.
    -   CPU는 메모리에 있는 프로그램 명령어를 하나씩 읽어오고 실행한다.  
        즉, 컴퓨터 프로그램은 메모리에 저장되어 있다가 필요할 때 CPU에 의해 실행된다.
3.  **CPU(중앙 처리 장치)**
    -   CPU는  **명령어를 순차적으로 실행**하며, 이 과정에서 메모리에서 데이터를 가져와 처리하고, 처리 결과를 다시 메모리에 저장한다.
    -   폰 노이만 구조에서 CPU의 3가지 구성 요소:
        -   **Control Unit(제어 장치)**: 명령어를 해석하고 실행 순서를 제어
        -   **ALU(산술 논리 장치)**: 산술 연산과 논리 연산을 수행
        -   **Register(레지스터)**: CPU 내부에서 임시로 데이터를 저장, 연산 속도를 높이는 데 사용
4.  **순차적 명령어 처리**
    -   CPU는  **PC(프로그램 카운터)**에 따라 메모리에서 명령어를 순차적으로 읽어와 처리한다.
    -   명령어는  **Fetch**  →  **Decode**  →  **Execute**의 3단계로 실행된다:
        -   1.  **Fetch (가져오기)**: 메모리에서 다음 실행할 명령어를 가져온다.
        -   1.  **Decode (해석)**: 명령어를 해석하여 어떤 작업을 해야 할지 파악한다.
        -   1.  **Execute (실행)**: 해석된 명령어를 실제로 실행한다.
5.  **Bus System**
    -   **Bus System**을 사용하여 CPU, 메모리, 입력/출력 장치 간에 데이터를 주고받는다.
6.  **병목 현상**
    -   **단일 버스 구조**  때문에 CPU가 메모리에서 데이터를 읽고 명령어를 가져오는 속도가 제한되는 문제.
    -   CPU와 메모리 간의 데이터 전송 속도 차이로 인해, CPU가 명령어를 빠르게 처리하고 싶어도 메모리에서 데이터를 불러오는 데 시간이 걸리면서 처리 속도가 느려질 수 있다.

<br><br>     

<img src="assets/img/Von Neumann 2.png" alt="Von Neumann 2" width="500"/>
<br><br>   

1. Data Path (데이터 경로)
- CPU 내부에서 데이터가 이동하고 처리되는 경로.
- ALU, Register, Bus 와 같은 하드웨어 구성 요소로 구성.
- ALU에서 산술 및 논리 연산을 처리(Execute)하고, Register에서 데이터를 임시 저장하며, Bus를 통해 메모리와 데이터를 주고받는다.

2. Control Unit (제어 장치)
- 제어 장치는 CPU 내부에서 명령을 해석하고, 시스템의 다른 모든 구성 요소의 작동을 조정하는 장치.
- 메모리에 저장된 명령어를 순차적으로 가져와(Fetch), 이를 해석한 후(Decode), 데이터 경로에 필요한 동작을 지시. 
- 제어 장치는 CPU의 실행 흐름을 조절하는 중앙적인 역할을 하며, 데이터 경로와 메모리, 입출력 장치 등 모든 구성 요소를 제어한다. 

3. Memory
- 메모리는 프로그램이 실행되는 동안 명령어와 데이터를 저장하며, 제어 장치와 데이터 경로의 요청에 따라 데이터를 제공하거나 결과를 저장한다.

----------



**Instruction Set (명령어 집합)**  
**Instruction Set**은 컴퓨터가 이해하고 실행할 수 있는 명령어들의 집합을 말합니다. 프로그래머나 컴파일러는 이 명령어 집합을 사용하여 프로그램을 작성하며, 컴퓨터의 하드웨어는 이 명령어들을 실행합니다.

### Instruction Set의 주요 개념:
- **명령어 포맷**: 각 명령어가 어떻게 구성되는지 (예: opcode, operand).
- **명령어의 유형**: 산술, 논리 연산, 데이터 전송, 제어 흐름 등.
- **레지스터**: 명령어가 레지스터를 어떻게 사용하고 데이터를 처리하는지.
- **주소 모드**: 데이터를 접근하는 방법 (즉시 값, 메모리, 레지스터 등).
**ISA (Instruction Set Architecture)**는 컴퓨터 시스템의 하드웨어와 소프트웨어 사이의 인터페이스를 정의하는 아키텍처입니다. **ISA**는 CPU가 수행할 수 있는 명령어들의 집합과 그 명령어가 어떻게 처리되는지를 설명하는 규칙들을 포함합니다.

### ISA의 구성 요소:
1. **명령어 형식**: 명령어가 어떻게 구성되는지 (예: opcode, operand).
2. **레지스터**: 프로세서가 데이터를 저장하고 처리할 수 있는 내부 저장 공간.
3. **데이터 타입**: 프로세서가 처리할 수 있는 데이터 유형 (정수, 부동 소수점 등).
4. **주소 모드**: 데이터를 가져오고 저장하는 방법 (즉시, 메모리, 레지스터 등).
5. **명령어 집합**: 프로세서가 실행할 수 있는 모든 명령어들의 목록.

**ISA**는 컴퓨터 설계의 중요한 부분으로, 프로세서의 성능, 효율성, 프로그래머의 편의성에 큰 영향을 미칩니다. 

---

### CISC (Complex Instruction Set Computing)
**CISC**는 복잡한 명령어 집합을 특징으로 하는 ISA의 유형입니다. 복잡한 명령어들이 많아 명령어 하나로 다양한 작업을 수행할 수 있습니다.

- **장점**: 코드가 짧아지고 복잡한 작업을 한 번에 처리할 수 있음.
- **단점**: 명령어가 복잡해지고 실행 시간이 오래 걸리며, 하드웨어 구현이 복잡함.

---

### RISC (Reduced Instruction Set Computing)
**RISC**는 단순한 명령어 집합을 특징으로 하는 ISA의 유형입니다. 명령어 하나가 간단하며, 동일한 실행 시간을 갖도록 설계되었습니다.

- **장점**: 단순한 명령어로 빠른 처리 속도를 얻을 수 있으며, 하드웨어 구현이 상대적으로 간단함.
- **단점**: 더 많은 명령어가 필요할 수 있어 코드 길이가 길어질 수 있음.

---

**RISC**와 **CISC**의 차이점은 주로 명령어의 복잡성과 실행 속도에 관련된 것입니다. RISC는 명령어가 단순해 빠르고, CISC는 복잡하지만 코드가 더 압축적입니다.

**CISC (Complex Instruction Set Computing)**  
**CISC**는 복잡한 명령어 집합을 가진 아키텍처를 말합니다. 명령어 한 개가 매우 복잡할 수 있고, 메모리 접근이나 복잡한 연산을 한 번에 처리할 수 있습니다.

### CISC의 주요 특징:
- **복잡한 명령어**: 한 개의 명령어로 여러 작업을 처리할 수 있음.
- **변수 길이의 명령어**: 명령어 길이가 다양함.
- **메모리 접근 빈도 높음**: 명령어가 메모리를 많이 사용하여 데이터 처리.
- **마이크로프로그램 사용**: 복잡한 명령어들은 내부적으로 여러 하위 명령어로 나뉘어 실행됨.

**장점**: 프로그래밍이 더 쉬워지고, 명령어 수가 줄어들어 코드가 더 짧아질 수 있음.  
**단점**: 복잡한 명령어를 처리하기 위한 하드웨어와 제어 회로가 더 복잡하고 느림.

**RISC (Reduced Instruction Set Computing)**  
**RISC**는 단순하고 효율적인 명령어 집합을 가진 아키텍처입니다. 명령어 하나가 단순하고 일정한 시간 안에 실행될 수 있게 설계되었습니다.

### RISC의 주요 특징:
- **단순한 명령어**: 각 명령어는 단순한 작업을 빠르게 처리할 수 있음.
- **고정 길이의 명령어**: 명령어의 길이가 동일하여 처리 속도가 일정함.
- **레지스터 중심 연산**: 메모리보다는 레지스터에서 데이터를 처리하여 속도를 높임.
- **파이프라이닝 지원**: 명령어 처리 단계를 분할하여 병렬 처리가 가능하게 설계됨.

**장점**: 하드웨어가 단순하고 효율적이며, 명령어 처리 속도가 매우 빠름.  
**단점**: 더 많은 명령어가 필요하므로 코드 길이가 길어질 수 있음.

---

### CISC vs. RISC
- **CISC**는 복잡한 명령어를 사용하여 한 번에 많은 일을 처리할 수 있지만, 명령어의 복잡성 때문에 속도가 느릴 수 있습니다.
- **RISC**는 단순한 명령어를 사용하여 명령어 처리 속도를 높이며, 파이프라이닝 같은 기술을 통해 성능을 극대화할 수 있습니다.

CISC는 주로 과거의 컴퓨터에 사용되었고, RISC는 현대의 고성능 프로세서에 많이 사용되고 있습니다.